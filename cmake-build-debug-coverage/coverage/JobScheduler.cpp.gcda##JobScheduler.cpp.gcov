        -:    0:Source:/home/dennis/CLionProjects/Project-3/JobScheduler.cpp
        -:    0:Graph:/home/dennis/CLionProjects/Project-3/cmake-build-debug-coverage/CMakeFiles/Project_3.dir/JobScheduler.cpp.gcno
        -:    0:Data:/home/dennis/CLionProjects/Project-3/cmake-build-debug-coverage/CMakeFiles/Project_3.dir/JobScheduler.cpp.gcda
        -:    0:Runs:1
        -:    1:#include <iostream>
        -:    2:#include <thread>
        -:    3:#include <csignal>
        -:    4:#include <unistd.h>
        -:    5:#include "JobScheduler.h"
        -:    6:#include "Queue.h"
        -:    7:#include "ctime"
        -:    8:
        -:    9:
        -:   10:
        -:   11:using namespace std;
        -:   12:
        -:   13:queue<Job*> myqueue;
        -:   14:pthread_mutex_t lock1; //first mutex
        -:   15:thread **threads;
        -:   16:bool destroyThreads = false;
        -:   17:std::time_t start = std::time(nullptr);
        -:   18:std::time_t now = std::time(nullptr);
        -:   19:
        -:   20:
 20271934:   21:Job *getJobInFIFO() {
 20271934:   22:    if (myqueue.size() == 0)
 20271934:   22-block  0
 20271927:   23:        return nullptr;
 20271927:   23-block  0
        -:   24:
        7:   25:    Job *tmp = myqueue.front();
        7:   25-block  0
        7:   26:    myqueue.pop();
        7:   27:    return tmp;
        -:   28:    //Job *torun = myqueue->pop();
        -:   29:    //return torun;
        -:   30:}
        -:   31:
        -:   32:
 20271939:   33:void thread_execute(){
 20271939:   34:    while ((now - start) < 6){
 20271939:   34-block  0
 20271934:   34-block  1
        -:   35:
 20271934:   36:        pthread_mutex_lock(&lock1);
 20271934:   36-block  0
 20271934:   37:        now = std::time(nullptr);
 20271934:   38:        Job *toexecute = getJobInFIFO();
 20271934:   39:        pthread_mutex_unlock(&lock1);
 20271934:   40:        if (toexecute != nullptr){
        -:   41:            //toexecute call functon reference
        7:   42:            toexecute->executeJob();
        7:   42-block  0
        7:   43:            delete toexecute;
        7:   43-block  0
        -:   44:        }
        -:   45:    }
        -:   46:    //if (destroyThreads)
        -:   47:        //cout << "Thread Terminated" << endl;
        -:   48:    //else
        -:   49:        //cout << "Thread Exited" << endl;
        -:   50:
        5:   51:}
        -:   52:
        1:   53:void createThreads(int num,thread::id *tids){
       1*:   54:    threads = new thread*[num];
        1:   54-block  0
        1:   54-block  1
    %%%%%:   54-block  2
        1:   54-block  3
        6:   55:    for (int i  = 0 ; i < num; i++){
        6:   55-block  0
        5:   56:        threads[i] = new thread(thread_execute);
        5:   56-block  0
    $$$$$:   56-block  1
        5:   57:        tids[i] = threads[i]->get_id();
        5:   57-block  0
        -:   58:    }
        -:   59:
        -:   60:
        1:   61:}
        1:   61-block  0
        -:   62:
    #####:   63:JobScheduler::JobScheduler() {
    %%%%%:   63-block  0
    $$$$$:   63-block  1
    #####:   64:    execution_threads = 1;
    #####:   65:    cout << "WARNING: Scheduler Initialized with no arguments!!\nOnly 1 Thread will be created!!" << endl;
    %%%%%:   65-block  0
    #####:   66:    initialize_scheduler(1);
    %%%%%:   66-block  0
    #####:   67:    return;
    %%%%%:   67-block  0
    %%%%%:   67-block  1
        -:   68:}
        -:   69:
        1:   70:JobScheduler::JobScheduler(int numThreads) {
        1:   70-block  0
    $$$$$:   70-block  1
        1:   71:    initialize_scheduler(numThreads);
        1:   72:}
        1:   72-block  0
        -:   73:
        -:   74:
        1:   75:JobScheduler *JobScheduler::initialize_scheduler(int numThreads) {
        1:   76:    execution_threads = numThreads;
        6:   77:    tids = new thread::id[5];
        1:   77-block  0
        6:   77-block  1
        5:   77-block  2
        -:   78:    //queue = new Queue();
        1:   79:    myqueue = queue;
        1:   79-block  0
        1:   80:    createThreads(execution_threads,tids);
        1:   81:    return nullptr;
        -:   82:
        -:   83:}
        -:   84:
        7:   85:int JobScheduler::submit_job( Job *j) {
        7:   86:    myqueue.push(j);
        7:   86-block  0
        7:   87:    return 0;
        -:   88:}
        -:   89:
    #####:   90:int JobScheduler::execute_all_jobs() {
    #####:   91:    return 0;
    %%%%%:   91-block  0
        -:   92:}
        -:   93:
        1:   94:int JobScheduler::wait_all_tasks_finish() {
        -:   95:    // synchronize threads:
        1:   96:    cout << "Main Thread: Waiting Threads to finish" << endl;
        1:   96-block  0
        6:   97:    for (int i  = 0 ; i < execution_threads; i++){
        6:   97-block  0
        5:   98:        threads[i]->join();
        5:   98-block  0
        -:   99:    }
        1:  100:    return 0;
        1:  100-block  0
        -:  101:}
        -:  102:
    #####:  103:int JobScheduler::destroy_scheduler() {
    #####:  104:    destroyThreads = true;
        -:  105:
    #####:  106:    return 0;
    %%%%%:  106-block  0
        -:  107:}
        -:  108:
        -:  109:
        1:  110:JobScheduler::~JobScheduler() {
        1:  110-block  0
        1:  111:    pthread_mutex_destroy(&lock1);
        1:  111-block  0
        6:  112:    for (int i = 0 ; i < execution_threads; i++){
        6:  112-block  0
        5:  112-block  1
        5:  113:        if (threads[i]->joinable())
        5:  113-block  0
    #####:  114:            threads[i]->detach();
    %%%%%:  114-block  0
        5:  115:        delete threads[i];
        5:  115-block  0
        5:  115-block  1
        -:  116:    }
        1:  117:    delete[] threads;
        1:  117-block  0
        1:  117-block  1
        -:  118:    //
        -:  119:    // delete myqueue;
        1:  120:    delete[] tids;
        1:  120-block  0
        1:  120-block  1
        1:  121:}
        -:  122:
